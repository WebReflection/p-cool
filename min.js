/*! (c) Andrea Giammarchi - ISC */
const t=Symbol("extends"),e={Anchor:"A",DList:"DL",Directory:"Dir",Heading:["H6","H5","H4","H3","H2","H1"],Image:"Img",OList:"OL",Paragraph:"P",TableCaption:"Caption",TableCell:["TH","TD"],TableRow:"TR",UList:"UL",Element:["Article","Aside","Footer","Header","Main","Nav","Section","Element"]},{customElements:a}=self,{define:s}=a,o=new WeakMap,n=(e,n)=>{const c=[e,n];return t in n&&c.push({extends:n[t].toLowerCase()}),s.apply(a,c),o.set(n,e),n},c=(t,e)=>e?n(t,e):e=>n(t,e),l={};Object.getOwnPropertyNames(self).forEach((a=>{if(/^HTML.*?Element$/.test(a)){const s=a.slice(4,-7)||"Element",n=self[a];[].concat(e[s]||s).forEach((e=>{l[s]=l[e]="Element"===e?class extends n{}:class extends n{static get[t](){return e}constructor(){super().hasAttribute("is")||this.setAttribute("is",o.get(this.constructor))}}}))}}));
const i=new Map,r=new WeakMap;function*b(t,e){const{behaviors:a,classList:s}=r.get(t);for(const t of e||s)if(i.has(t))for(const e of i.get(t))yield[a,e]}const d=t=>class extends t{static get observedAttributes(){return["class"]}constructor(){r.set(super(),{behaviors:new Map,classList:[]})}connectedCallback(){h(this,"connectedCallback",!0)}disconnectedCallback(){h(this,"disconnectedCallback",!1)}attributeChangedCallback(){let t=!1;const e=this,a=r.get(e),{classList:s}=a,o=new Set(s);(a.classList=[...e.classList]).forEach(o.delete,o);for(const[a,s]of b(e))if(!a.has(s)){t=!0;const o={mo:null,live:!1};a.set(s,o),"attachedCallback"in s&&s.attachedCallback(e);let{observedAttributes:n}=s;if(n||"attributeChangedCallback"in s){o.mo=new MutationObserver(u),o.mo.observe(e,{attributeOldValue:!0,attributes:!0,attributeFilter:n});const t=[];for(const a of n||[...e.attributes].map((({name:t})=>t)))e.hasAttribute(a)&&t.push({target:e,attributeName:a,oldValue:null});u(t,o.mo)}}t&&e.isConnected&&h(e,"connectedCallback",t),f(e,o)}},u=(t,e)=>{for(const{target:a,attributeName:s,oldValue:o}of t){const{behaviors:t}=r.get(a);for(const[n,{mo:c}]of t.entries())c===e&&"attributeChangedCallback"in n&&n.attributeChangedCallback(a,s,o,a.getAttribute(s))}},f=(t,e)=>{for(const[a,s]of b(t,e))if(a.has(s)){const{mo:e,live:o}=a.get(s);e&&e.disconnect(),a.delete(s),o&&"disconnectedCallback"in s&&s.disconnectedCallback(t),"detachedCallback"in s&&s.detachedCallback(t)}},h=(t,e,a)=>{for(const[s,o]of b(t))if(e in o){const n=s.get(o);n.live!==a&&(n.live=a,o[e](t))}},C=new Set;for(const t in l){const e=l[t],a=Object.getOwnPropertySymbols(e).filter((({description:t})=>"extends"===t));let s="p-cool";if(a.length&&(s+="-"+e[a[0]].toLowerCase()),!C.has(s)){C.add(s);try{c(s,d(e))}catch(t){}}}const g=(t,e,a=document)=>{((t,e)=>{i.has(t)||i.set(t,new Set),i.get(t).add(e)})(t,e);const s=`p-cool.${t},[is^="p-cool"].${t}`;for(const t of a.querySelectorAll(s))"attributeChangedCallback"in t&&t.attributeChangedCallback()};export{g as define};
