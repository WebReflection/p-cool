/*! (c) Andrea Giammarchi - ISC */
try{if(!self.customElements.get("f-d")){class y extends HTMLLIElement{}self.customElements.define("f-d",y,{extends:"li"}),new y}}catch(C){const{keys:v}=Object,k=e=>{const t=v(e),n=[],{length:o}=t;for(let a=0;a<o;a++)n[a]=e[t[a]],delete e[t[a]];return()=>{for(let a=0;a<o;a++)e[t[a]]=n[a]}},S=!0,A=!1,E="querySelectorAll",H=(e,t=document,n=MutationObserver,o=["*"])=>{const a=(t,n,o,s,l,r)=>{for(const c of t)(r||E in c)&&(l?o.has(c)||(o.add(c),s.delete(c),e(c,l)):s.has(c)||(s.add(c),o.delete(c),e(c,l)),r||a(c[E](n),n,o,s,l,S))},s=new n((e=>{if(o.length){const t=o.join(","),n=new Set,s=new Set;for(const{addedNodes:o,removedNodes:l}of e)a(l,t,n,s,A,A),a(o,t,n,s,S,A)}})),{observe:l}=s;return(s.observe=e=>l.call(s,e,{subtree:S,childList:S}))(t),s},L="querySelectorAll",{document:M,Element:T,MutationObserver:O,Set:x,WeakMap:N}=self,$=e=>L in e,{filter:q}=[];var e=e=>{const t=new N,n=(n,o)=>{let s;if(o)for(let l,r=(e=>e.matches||e.webkitMatchesSelector||e.msMatchesSelector)(n),c=0,{length:i}=a;c<i;c++)r.call(n,l=a[c])&&(t.has(n)||t.set(n,new x),s=t.get(n),s.has(l)||(s.add(l),e.handle(n,o,l)));else t.has(n)&&(s=t.get(n),t.delete(n),s.forEach((t=>{e.handle(n,o,t)})))},o=(e,t=!0)=>{for(let o=0,{length:a}=e;o<a;o++)n(e[o],t)},{query:a}=e,s=e.root||M,l=H(n,s,O,a),{attachShadow:r}=T.prototype;return r&&(T.prototype.attachShadow=function(e){const t=r.call(this,e);return l.observe(t),t}),a.length&&o(s[L](a)),{drop:e=>{for(let n=0,{length:o}=e;n<o;n++)t.delete(e[n])},flush:()=>{const e=l.takeRecords();for(let t=0,{length:n}=e;t<n;t++)o(q.call(e[t].removedNodes,$),!1),o(q.call(e[t].addedNodes,$),!0)},observer:l,parse:o}};const{customElements:P,document:D,Element:V,MutationObserver:R,Object:j,Promise:F,Map:I,Set:W,WeakMap:U,Reflect:_}=self,{createElement:B}=D,{define:z,get:G,upgrade:J}=P,{construct:K}=_||{construct(e){return e.call(this)}},{defineProperty:Q,getOwnPropertyNames:X,setPrototypeOf:Y}=j,Z=new U,ee=new W,te=new I,ne=new I,oe=new I,ae=new I,se=[],le=[],re=e=>ae.get(e)||G.call(P,e),ce=(e,t,n)=>{const o=oe.get(n);if(t&&!o.isPrototypeOf(e)){const t=k(e);be=Y(e,o);try{new o.constructor}finally{be=null,t()}}const a=(t?"":"dis")+"connectedCallback";a in o&&e[a]()},{parse:ie}=e({query:le,handle:ce}),{parse:ue}=e({query:se,handle(e,n){Z.has(e)&&(n?ee.add(e):ee.delete(e),le.length&&t.call(le,e))}}),{attachShadow:de}=V.prototype;de&&(V.prototype.attachShadow=function(e){const t=de.call(this,e);return Z.set(this,t),t});const fe=e=>{if(!ne.has(e)){let t,n=new F((e=>{t=e}));ne.set(e,{$:n,_:t})}return ne.get(e).$},he=((e,t)=>{const n=e=>{for(let t=0,{length:n}=e;t<n;t++)o(e[t])},o=({target:e,attributeName:t,oldValue:n})=>{e.attributeChangedCallback(t,n,e.getAttribute(t))};return(a,s)=>{const{observedAttributes:l}=a.constructor;return l&&e(s).then((()=>{new t(n).observe(a,{attributes:!0,attributeOldValue:!0,attributeFilter:l});for(let e=0,{length:t}=l;e<t;e++)a.hasAttribute(l[e])&&o({target:a,attributeName:l[e],oldValue:null})})),a}})(fe,R);let be=null;function t(e){const t=Z.get(e);ie(t.querySelectorAll(this),e.isConnected)}X(self).filter((e=>/^HTML.*Element$/.test(e))).forEach((e=>{const t=self[e];function n(){const{constructor:e}=this;if(!te.has(e))throw new TypeError("Illegal constructor");const{is:n,tag:o}=te.get(e);if(n){if(be)return he(be,n);const t=B.call(D,o);return t.setAttribute("is",n),he(Y(t,e.prototype),n)}return K.call(this,t,[],e)}Y(n,t),Q(n.prototype=t.prototype,"constructor",{value:n}),Q(self,e,{value:n})})),Q(D,"createElement",{configurable:!0,value(e,t){const n=t&&t.is;if(n){const t=ae.get(n);if(t&&te.get(t).tag===e)return new t}const o=B.call(D,e);return n&&o.setAttribute("is",n),o}}),Q(P,"get",{configurable:!0,value:re}),Q(P,"whenDefined",{configurable:!0,value:fe}),Q(P,"upgrade",{configurable:!0,value(e){const t=e.getAttribute("is");if(t){const n=ae.get(t);if(n)return void he(Y(e,n.prototype),t)}J.call(P,e)}}),Q(P,"define",{configurable:!0,value(e,n,o){if(re(e))throw new Error(`'${e}' has already been defined as a custom element`);let a;const s=o&&o.extends;te.set(n,s?{is:e,tag:s}:{is:"",tag:e}),s?(a=`${s}[is="${e}"]`,oe.set(a,n.prototype),ae.set(e,n),le.push(a)):(z.apply(P,arguments),se.push(a=e)),fe(e).then((()=>{s?(ie(D.querySelectorAll(a)),ee.forEach(t,[a])):ue(D.querySelectorAll(a))})),ne.get(e)._(n)}})}const n={A:"Anchor",Caption:"TableCaption",DL:"DList",Dir:"Directory",Img:"Image",OL:"OList",P:"Paragraph",TR:"TableRow",UL:"UList",Article:"",Aside:"",Footer:"",Header:"",Main:"",Nav:"",Element:"",H1:"Heading",H2:"Heading",H3:"Heading",H4:"Heading",H5:"Heading",H6:"Heading",TD:"TableCell",TH:"TableCell",TBody:"TableSection",TFoot:"TableSection",THead:"TableSection"},o=Symbol("extends"),{customElements:a}=self,{define:s}=a,l=new Map,r=(e,t)=>{const n=[e,t];return o in t&&n.push({extends:t[o].toLowerCase()}),s.apply(a,n),l.set(t,e),t},c=(e,t)=>t?r(e,t):t=>r(e,t),i=new Proxy(new Map,{get(e,t){if(!e.has(t)){const s=self[(a=t,"HTML"+(a in n?n[a]:a)+"Element")];e.set(t,"Element"===t?class extends s{}:class extends s{static get[o](){return t}constructor(){super().hasAttribute("is")||this.setAttribute("is",l.get(this.constructor))}})}var a;return e.get(t)}}),u=new Map,d=new WeakMap;function*f(e,t){const{behaviors:n,classList:o}=d.get(e);for(const e of t||o)if(u.has(e))for(const t of u.get(e))yield[n,t]}const h=e=>class extends e{static get observedAttributes(){return["class"]}constructor(){d.set(super(),{behaviors:new Map,classList:[]})}connectedCallback(){p(this,"connectedCallback",!0)}disconnectedCallback(){p(this,"disconnectedCallback",!1)}attributeChangedCallback(){let e=!1;const t=this,n=d.get(t),{classList:o}=n,a=new Set(o);(n.classList=[...t.classList]).forEach(a.delete,a);for(const[n,o]of f(t))if(!n.has(o)){e=!0;const a={mo:null,live:!1};n.set(o,a),"attachedCallback"in o&&o.attachedCallback(t);let{observedAttributes:s}=o;if(s||"attributeChangedCallback"in o){a.mo=new MutationObserver(b),a.mo.observe(t,{attributeOldValue:!0,attributes:!0,attributeFilter:s});const e=[];for(const n of s||[...t.attributes].map((({name:e})=>e)))t.hasAttribute(n)&&e.push({target:t,attributeName:n,oldValue:null});b(e,a.mo)}}e&&t.isConnected&&p(t,"connectedCallback",e),g(t,a)}},b=(e,t)=>{for(const{target:n,attributeName:o,oldValue:a}of e){const{behaviors:e}=d.get(n);for(const[s,{mo:l}]of e.entries())l===t&&"attributeChangedCallback"in s&&s.attributeChangedCallback(n,o,a,n.getAttribute(o))}},g=(e,t)=>{for(const[n,o]of f(e,t))if(n.has(o)){const{mo:t,live:a}=n.get(o);t&&t.disconnect(),n.delete(o),a&&"disconnectedCallback"in o&&o.disconnectedCallback(e),"detachedCallback"in o&&o.detachedCallback(e)}},p=(e,t,n)=>{for(const[o,a]of f(e))if(t in a){const s=o.get(a);s.live!==n&&(s.live=n,a[t](e))}},m=new Set;for(const ge of Object.getOwnPropertyNames(self))if(/^HTML(.*?)Element$/.test(ge)){const pe=i[RegExp.$1||"Element"];let me="p-cool";if(o in pe&&(me+="-"+pe[o].toLowerCase()),!m.has(me)){m.add(me);try{c(me,h(pe))}catch(we){}}}const w=(e,t,n=document)=>{((e,t)=>{u.has(e)||u.set(e,new Set),u.get(e).add(t)})(e,t);const o=`p-cool.${e},[is^="p-cool"].${e}`;for(const e of n.querySelectorAll(o))"attributeChangedCallback"in e&&e.attributeChangedCallback()};export{w as define};
