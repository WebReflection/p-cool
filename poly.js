/*! (c) Andrea Giammarchi - ISC */
try{class e extends HTMLParagraphElement{}self.customElements.define("p-"+Date.now(),e,{extends:"p"}),new e}catch(s){const{keys:a}=Object,o=e=>{const t=a(e),n=[],{length:s}=t;for(let a=0;a<s;a++)n[a]=e[t[a]],delete e[t[a]];return()=>{for(let a=0;a<s;a++)e[t[a]]=n[a]}},l=!0,r=!1,c="querySelectorAll";function e(e){this.observe(e,{subtree:l,childList:l})}const i=(t,n,s)=>{const a=(e,n,s,o,r)=>{for(let i=0,{length:d}=e;i<d;i++){const d=e[i];(r||c in d)&&(o?n.has(d)||(n.add(d),s.delete(d),t(d,o)):s.has(d)||(s.add(d),n.delete(d),t(d,o)),r||a(d[c]("*"),n,s,o,l))}},o=new(s||MutationObserver)((e=>{for(let t=new Set,n=new Set,s=0,{length:o}=e;s<o;s++){const{addedNodes:o,removedNodes:c}=e[s];a(c,t,n,r,r),a(o,t,n,l,r)}}));return o.add=e,o.add(n||document),o},d="querySelectorAll",{document:u,Element:h,MutationObserver:f,Set:b,WeakMap:g}=self,p=e=>d in e,{filter:m}=[];var t=e=>{const t=new g,n=(n,s)=>{let o;if(s)for(let l,r=(e=>e.matches||e.webkitMatchesSelector||e.msMatchesSelector)(n),c=0,{length:i}=a;c<i;c++)r.call(n,l=a[c])&&(t.has(n)||t.set(n,new b),o=t.get(n),o.has(l)||(o.add(l),e.handle(n,s,l)));else t.has(n)&&(o=t.get(n),t.delete(n),o.forEach((t=>{e.handle(n,s,t)})))},s=(e,t=!0)=>{for(let s=0,{length:a}=e;s<a;s++)n(e[s],t)},{query:a}=e,o=e.root||u,l=i(n,o,f),{attachShadow:r}=h.prototype;return r&&(h.prototype.attachShadow=function(e){const t=r.call(this,e);return l.add(t),t}),a.length&&s(o[d](a)),{drop:e=>{for(let n=0,{length:s}=e;n<s;n++)t.delete(e[n])},flush:()=>{const e=l.takeRecords();for(let t=0,{length:n}=e;t<n;t++)s(m.call(e[t].removedNodes,p),!1),s(m.call(e[t].addedNodes,p),!0)},observer:l,parse:s}};const{customElements:w,document:y,Element:C,MutationObserver:v,Object:k,Promise:S,Map:A,Set:E,WeakMap:L,Reflect:M}=self,{attachShadow:O}=C.prototype,{createElement:H}=y,{define:N,get:x}=w,{construct:P}=M||{construct(e){return e.call(this)}},{defineProperty:T,getOwnPropertyNames:q,setPrototypeOf:$}=k,D=new L,V=new E,j=new A,R=new A,W=new A,F=new A,I=[],U=[],_=e=>F.get(e)||x.call(w,e),z=(e,t,n)=>{const s=W.get(n);if(t&&!s.isPrototypeOf(e)){const t=o(e);Q=$(e,s);try{new s.constructor}finally{Q=null,t()}}const a=(t?"":"dis")+"connectedCallback";a in s&&e[a]()},{parse:B}=t({query:U,handle:z}),{parse:G}=t({query:I,handle(e,t){D.has(e)&&(t?V.add(e):V.delete(e),U.length&&n.call(U,e))}}),J=e=>{if(!R.has(e)){let t,n=new S((e=>{t=e}));R.set(e,{$:n,_:t})}return R.get(e).$},K=((e,t)=>{const n=e=>{for(let t=0,{length:n}=e;t<n;t++)s(e[t])},s=({target:e,attributeName:t,oldValue:n})=>{e.attributeChangedCallback(t,n,e.getAttribute(t))};return(a,o)=>{const{observedAttributes:l}=a.constructor;return l&&e(o).then((()=>{new t(n).observe(a,{attributes:!0,attributeOldValue:!0,attributeFilter:l});for(let e=0,{length:t}=l;e<t;e++)a.hasAttribute(l[e])&&s({target:a,attributeName:l[e],oldValue:null})})),a}})(J,v);let Q=null;function n(e){const t=D.get(e);B(t.querySelectorAll(this),e.isConnected)}q(self).filter((e=>/^HTML/.test(e))).forEach((e=>{const t=self[e];function n(){const{constructor:e}=this;if(!j.has(e))throw new TypeError("Illegal constructor");const{is:n,tag:s}=j.get(e);if(n){if(Q)return K(Q,n);const t=H.call(y,s);return t.setAttribute("is",n),K($(t,e.prototype),n)}return P.call(this,t,[],e)}$(n,t),T(n.prototype=t.prototype,"constructor",{value:n}),T(self,e,{value:n})})),T(y,"createElement",{configurable:!0,value(e,t){const n=t&&t.is;if(n){const t=F.get(n);if(t&&j.get(t).tag===e)return new t}const s=H.call(y,e);return n&&s.setAttribute("is",n),s}}),O&&(C.prototype.attachShadow=function(e){const t=O.call(this,e);return D.set(this,t),t}),T(w,"get",{configurable:!0,value:_}),T(w,"whenDefined",{configurable:!0,value:J}),T(w,"define",{configurable:!0,value(e,t,s){if(_(e))throw new Error(`'${e}' has already been defined as a custom element`);let a;const o=s&&s.extends;j.set(t,o?{is:e,tag:o}:{is:"",tag:e}),o?(a=`${o}[is="${e}"]`,W.set(a,t.prototype),F.set(e,t),U.push(a)):(N.apply(w,arguments),I.push(a=e)),J(e).then((()=>{o?(B(y.querySelectorAll(a)),V.forEach(n,[a])):G(y.querySelectorAll(a))})),R.get(e)._(t)}})}const s=Symbol("extends"),a={Anchor:"A",DList:"DL",Directory:"Dir",Heading:["H6","H5","H4","H3","H2","H1"],Image:"Img",OList:"OL",Paragraph:"P",TableCaption:"Caption",TableCell:["TH","TD"],TableRow:"TR",UList:"UL",Element:["Article","Aside","Footer","Header","Main","Nav","Section","Element"]},{customElements:o}=self,{define:l}=o,r=new WeakMap,c=(e,t)=>{const n=[e,t];return s in t&&n.push({extends:t[s].toLowerCase()}),l.apply(o,n),r.set(t,e),t},i=(e,t)=>t?c(e,t):t=>c(e,t),d={};Object.getOwnPropertyNames(self).forEach((e=>{if(/^HTML.*?Element$/.test(e)){const t=e.slice(4,-7)||"Element",n=self[e];[].concat(a[t]||t).forEach((e=>{d[t]=d[e]="Element"===e?class extends n{}:class extends n{static get[s](){return e}constructor(){super().hasAttribute("is")||this.setAttribute("is",r.get(this.constructor))}}}))}}));
const u=new Map,h=new WeakMap;function*f(e,t){const{behaviors:n,classList:s}=h.get(e);for(const e of t||s)if(u.has(e))for(const t of u.get(e))yield[n,t]}const b=e=>class extends e{static get observedAttributes(){return["class"]}constructor(){h.set(super(),{behaviors:new Map,classList:[]})}connectedCallback(){m(this,"connectedCallback",!0)}disconnectedCallback(){m(this,"disconnectedCallback",!1)}attributeChangedCallback(){let e=!1;const t=this,n=h.get(t),{classList:s}=n,a=new Set(s);(n.classList=[...t.classList]).forEach(a.delete,a);for(const[n,s]of f(t))if(!n.has(s)){e=!0;const a={mo:null,live:!1};n.set(s,a),"attachedCallback"in s&&s.attachedCallback(t);let{observedAttributes:o}=s;if(o||"attributeChangedCallback"in s){a.mo=new MutationObserver(g),a.mo.observe(t,{attributeOldValue:!0,attributes:!0,attributeFilter:o});const e=[];for(const n of o||[...t.attributes].map((({name:e})=>e)))t.hasAttribute(n)&&e.push({target:t,attributeName:n,oldValue:null});g(e,a.mo)}}e&&t.isConnected&&m(t,"connectedCallback",e),p(t,a)}},g=(e,t)=>{for(const{target:n,attributeName:s,oldValue:a}of e){const{behaviors:e}=h.get(n);for(const[o,{mo:l}]of e.entries())l===t&&"attributeChangedCallback"in o&&o.attributeChangedCallback(n,s,a,n.getAttribute(s))}},p=(e,t)=>{for(const[n,s]of f(e,t))if(n.has(s)){const{mo:t,live:a}=n.get(s);t&&t.disconnect(),n.delete(s),a&&"disconnectedCallback"in s&&s.disconnectedCallback(e),"detachedCallback"in s&&s.detachedCallback(e)}},m=(e,t,n)=>{for(const[s,a]of f(e))if(t in a){const o=s.get(a);o.live!==n&&(o.live=n,a[t](e))}},w=new Set;for(const e in d){const t=d[e],n=Object.getOwnPropertySymbols(t).filter((({description:e})=>"extends"===e));let s="p-cool";if(n.length&&(s+="-"+t[n[0]].toLowerCase()),!w.has(s)){w.add(s);try{i(s,b(t))}catch(e){}}}const y=(e,t,n=document)=>{((e,t)=>{u.has(e)||u.set(e,new Set),u.get(e).add(t)})(e,t);const s=`p-cool.${e},[is^="p-cool"].${e}`;for(const e of n.querySelectorAll(s))"attributeChangedCallback"in e&&e.attributeChangedCallback()};export{y as define};
