/*! (c) Andrea Giammarchi - ISC */
try{class e extends HTMLParagraphElement{}self.customElements.define("p-"+Date.now(),e,{extends:"p"}),new e}catch(a){const{keys:s}=Object,o=e=>{const t=s(e),n=[],{length:a}=t;for(let s=0;s<a;s++)n[s]=e[t[s]],delete e[t[s]];return()=>{for(let s=0;s<a;s++)e[t[s]]=n[s]}},l=!0,r=!1,c="querySelectorAll";function e(e){this.observe(e,{subtree:l,childList:l})}const i=(t,n,a)=>{const s=(e,n,a,o,r)=>{for(let i=0,{length:d}=e;i<d;i++){const d=e[i];(r||c in d)&&(o?n.has(d)||(n.add(d),a.delete(d),t(d,o)):a.has(d)||(a.add(d),n.delete(d),t(d,o)),r||s(d[c]("*"),n,a,o,l))}},o=new(a||MutationObserver)((e=>{for(let t=new Set,n=new Set,a=0,{length:o}=e;a<o;a++){const{addedNodes:o,removedNodes:c}=e[a];s(c,t,n,r,r),s(o,t,n,l,r)}}));return o.add=e,o.add(n||document),o},d="querySelectorAll",{document:u,Element:h,MutationObserver:f,Set:b,WeakMap:g}=self,p=e=>d in e,{filter:m}=[];var t=e=>{const t=new g,n=(n,a)=>{let o;if(a)for(let l,r=(e=>e.matches||e.webkitMatchesSelector||e.msMatchesSelector)(n),c=0,{length:i}=s;c<i;c++)r.call(n,l=s[c])&&(t.has(n)||t.set(n,new b),o=t.get(n),o.has(l)||(o.add(l),e.handle(n,a,l)));else t.has(n)&&(o=t.get(n),t.delete(n),o.forEach((t=>{e.handle(n,a,t)})))},a=(e,t=!0)=>{for(let a=0,{length:s}=e;a<s;a++)n(e[a],t)},{query:s}=e,o=e.root||u,l=i(n,o,f),{attachShadow:r}=h.prototype;return r&&(h.prototype.attachShadow=function(e){const t=r.call(this,e);return l.add(t),t}),s.length&&a(o[d](s)),{drop:e=>{for(let n=0,{length:a}=e;n<a;n++)t.delete(e[n])},flush:()=>{const e=l.takeRecords();for(let t=0,{length:n}=e;t<n;t++)a(m.call(e[t].removedNodes,p),!1),a(m.call(e[t].addedNodes,p),!0)},observer:l,parse:a}};const{customElements:w,document:y,Element:C,MutationObserver:v,Object:k,Promise:A,Map:E,Set:S,WeakMap:L,Reflect:M}=self,{attachShadow:O}=C.prototype,{createElement:H}=y,{define:N,get:T}=w,{construct:q}=M||{construct(e){return e.call(this)}},{defineProperty:x,getOwnPropertyNames:P,setPrototypeOf:$}=k,D=new L,V=new S,R=new E,W=new E,j=new E,F=new E,I=[],U=[],_=e=>F.get(e)||T.call(w,e),z=(e,t,n)=>{const a=j.get(n);if(t&&!a.isPrototypeOf(e)){const t=o(e);Q=$(e,a);try{new a.constructor}finally{Q=null,t()}}const s=(t?"":"dis")+"connectedCallback";s in a&&e[s]()},{parse:B}=t({query:U,handle:z}),{parse:G}=t({query:I,handle(e,t){D.has(e)&&(t?V.add(e):V.delete(e),U.length&&n.call(U,e))}}),J=e=>{if(!W.has(e)){let t,n=new A((e=>{t=e}));W.set(e,{$:n,_:t})}return W.get(e).$},K=((e,t)=>{const n=e=>{for(let t=0,{length:n}=e;t<n;t++)a(e[t])},a=({target:e,attributeName:t,oldValue:n})=>{e.attributeChangedCallback(t,n,e.getAttribute(t))};return(s,o)=>{const{observedAttributes:l}=s.constructor;return l&&e(o).then((()=>{new t(n).observe(s,{attributes:!0,attributeOldValue:!0,attributeFilter:l});for(let e=0,{length:t}=l;e<t;e++)s.hasAttribute(l[e])&&a({target:s,attributeName:l[e],oldValue:null})})),s}})(J,v);let Q=null;function n(e){const t=D.get(e);B(t.querySelectorAll(this),e.isConnected)}P(self).filter((e=>/^HTML/.test(e))).forEach((e=>{const t=self[e];function n(){const{constructor:e}=this;if(!R.has(e))throw new TypeError("Illegal constructor");const{is:n,tag:a}=R.get(e);if(n){if(Q)return K(Q,n);const t=H.call(y,a);return t.setAttribute("is",n),K($(t,e.prototype),n)}return q.call(this,t,[],e)}$(n,t),x(n.prototype=t.prototype,"constructor",{value:n}),x(self,e,{value:n})})),x(y,"createElement",{configurable:!0,value(e,t){const n=t&&t.is;if(n){const t=F.get(n);if(t&&R.get(t).tag===e)return new t}const a=H.call(y,e);return n&&a.setAttribute("is",n),a}}),O&&(C.prototype.attachShadow=function(e){const t=O.call(this,e);return D.set(this,t),t}),x(w,"get",{configurable:!0,value:_}),x(w,"whenDefined",{configurable:!0,value:J}),x(w,"define",{configurable:!0,value(e,t,a){if(_(e))throw new Error(`'${e}' has already been defined as a custom element`);let s;const o=a&&a.extends;R.set(t,o?{is:e,tag:o}:{is:"",tag:e}),o?(s=`${o}[is="${e}"]`,j.set(s,t.prototype),F.set(e,t),U.push(s)):(N.apply(w,arguments),I.push(s=e)),J(e).then((()=>{o?(B(y.querySelectorAll(s)),V.forEach(n,[s])):G(y.querySelectorAll(s))})),W.get(e)._(t)}})}const a=Symbol("extends"),s={Anchor:"A",DList:"DL",Directory:"Dir",Heading:["H6","H5","H4","H3","H2","H1"],Image:"Img",OList:"OL",Paragraph:"P",TableCaption:"Caption",TableCell:["TH","TD"],TableRow:"TR",UList:"UL",Element:["Article","Aside","Footer","Header","Main","Nav","Section","Element"]},{customElements:o}=self,{define:l}=o,r=new WeakMap,c=(e,t)=>{const n=[e,t];return a in t&&n.push({extends:t[a].toLowerCase()}),l.apply(o,n),r.set(t,e),t},i=(e,t)=>t?c(e,t):t=>c(e,t),d={};Object.getOwnPropertyNames(self).forEach((e=>{if(/^HTML.*?Element$/.test(e)){const t=e.slice(4,-7)||"Element",n=self[e];[].concat(s[t]||t).forEach((e=>{d[t]=d[e]="Element"===e?class extends n{}:class extends n{static get[a](){return e}constructor(){super().hasAttribute("is")||this.setAttribute("is",r.get(this.constructor))}}}))}}));
const u=new Map,h=new WeakMap;function*f(e,t){const{behaviors:n,classList:a}=h.get(e);for(const e of t||a)if(u.has(e))for(const t of u.get(e))yield[n,t]}const b=e=>class extends e{static get observedAttributes(){return["class"]}constructor(){h.set(super(),{behaviors:new Map,classList:[]})}connectedCallback(){m(this,"connectedCallback",!0)}disconnectedCallback(){m(this,"disconnectedCallback",!1)}attributeChangedCallback(){let e=!1;const t=this,n=h.get(t),{classList:a}=n,s=new Set(a);(n.classList=[...t.classList]).forEach(s.delete,s);for(const[n,a]of f(t))if(!n.has(a)){e=!0;const s={mo:null,live:!1};n.set(a,s),"attachedCallback"in a&&a.attachedCallback(t);let{observedAttributes:o}=a;if(o||"attributeChangedCallback"in a){s.mo=new MutationObserver(g),s.mo.observe(t,{attributeOldValue:!0,attributes:!0,attributeFilter:o});const e=[];for(const n of o||[...t.attributes].map((({name:e})=>e)))t.hasAttribute(n)&&e.push({target:t,attributeName:n,oldValue:null});g(e,s.mo)}}e&&t.isConnected&&m(t,"connectedCallback",e),p(t,s)}},g=(e,t)=>{for(const{target:n,attributeName:a,oldValue:s}of e){const{behaviors:e}=h.get(n);for(const[o,{mo:l}]of e.entries())l===t&&"attributeChangedCallback"in o&&o.attributeChangedCallback(n,a,s,n.getAttribute(a))}},p=(e,t)=>{for(const[n,a]of f(e,t))if(n.has(a)){const{mo:t,live:s}=n.get(a);t&&t.disconnect(),n.delete(a),s&&"disconnectedCallback"in a&&a.disconnectedCallback(e),"detachedCallback"in a&&a.detachedCallback(e)}},m=(e,t,n)=>{for(const[a,s]of f(e))if(t in s){const o=a.get(s);o.live!==n&&(o.live=n,s[t](e))}},w=new Set;for(const e in d){const t=d[e];let n="p-cool";if(a in t&&(n+="-"+t[a].toLowerCase()),!w.has(n)){w.add(n);try{i(n,b(t))}catch(e){}}}const y=(e,t,n=document)=>{((e,t)=>{u.has(e)||u.set(e,new Set),u.get(e).add(t)})(e,t);const a=`p-cool.${e},[is^="p-cool"].${e}`;for(const e of n.querySelectorAll(a))"attributeChangedCallback"in e&&e.attributeChangedCallback()};export{y as define};
